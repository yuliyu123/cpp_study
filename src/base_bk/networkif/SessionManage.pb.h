// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SessionManage.proto

#ifndef PROTOBUF_SessionManage_2eproto__INCLUDED
#define PROTOBUF_SessionManage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "GeneralHeader.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_SessionManage_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[3];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void InitDefaultsEstablishSessionImpl();
void InitDefaultsEstablishSession();
void InitDefaultsSessionEstablished_SuccessResponseImpl();
void InitDefaultsSessionEstablished_SuccessResponse();
void InitDefaultsSessionEstablishedImpl();
void InitDefaultsSessionEstablished();
inline void InitDefaults() {
  InitDefaultsEstablishSession();
  InitDefaultsSessionEstablished_SuccessResponse();
  InitDefaultsSessionEstablished();
}
}  // namespace protobuf_SessionManage_2eproto
namespace networkif {
namespace protoc {
class EstablishSession;
class EstablishSessionDefaultTypeInternal;
extern EstablishSessionDefaultTypeInternal _EstablishSession_default_instance_;
class SessionEstablished;
class SessionEstablishedDefaultTypeInternal;
extern SessionEstablishedDefaultTypeInternal _SessionEstablished_default_instance_;
class SessionEstablished_SuccessResponse;
class SessionEstablished_SuccessResponseDefaultTypeInternal;
extern SessionEstablished_SuccessResponseDefaultTypeInternal _SessionEstablished_SuccessResponse_default_instance_;
}  // namespace protoc
}  // namespace networkif
namespace networkif {
namespace protoc {

enum EstablishSession_SessionType {
  EstablishSession_SessionType_CONTROL_SESSION = 1,
  EstablishSession_SessionType_CONTENT_TRANSMISSION = 2
};
bool EstablishSession_SessionType_IsValid(int value);
const EstablishSession_SessionType EstablishSession_SessionType_SessionType_MIN = EstablishSession_SessionType_CONTROL_SESSION;
const EstablishSession_SessionType EstablishSession_SessionType_SessionType_MAX = EstablishSession_SessionType_CONTENT_TRANSMISSION;
const int EstablishSession_SessionType_SessionType_ARRAYSIZE = EstablishSession_SessionType_SessionType_MAX + 1;

enum SessionEstablished_SessionEstablishedResult {
  SessionEstablished_SessionEstablishedResult_SUCCESS = 1,
  SessionEstablished_SessionEstablishedResult_INVALID_UNSPECIFIED = 2,
  SessionEstablished_SessionEstablishedResult_SESSIONS_LIMIT_EXCEEDED = 3
};
bool SessionEstablished_SessionEstablishedResult_IsValid(int value);
const SessionEstablished_SessionEstablishedResult SessionEstablished_SessionEstablishedResult_SessionEstablishedResult_MIN = SessionEstablished_SessionEstablishedResult_SUCCESS;
const SessionEstablished_SessionEstablishedResult SessionEstablished_SessionEstablishedResult_SessionEstablishedResult_MAX = SessionEstablished_SessionEstablishedResult_SESSIONS_LIMIT_EXCEEDED;
const int SessionEstablished_SessionEstablishedResult_SessionEstablishedResult_ARRAYSIZE = SessionEstablished_SessionEstablishedResult_SessionEstablishedResult_MAX + 1;

// ===================================================================

class EstablishSession : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:networkif.protoc.EstablishSession) */ {
 public:
  EstablishSession();
  virtual ~EstablishSession();

  EstablishSession(const EstablishSession& from);

  inline EstablishSession& operator=(const EstablishSession& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EstablishSession(EstablishSession&& from) noexcept
    : EstablishSession() {
    *this = ::std::move(from);
  }

  inline EstablishSession& operator=(EstablishSession&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const EstablishSession& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EstablishSession* internal_default_instance() {
    return reinterpret_cast<const EstablishSession*>(
               &_EstablishSession_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(EstablishSession* other);
  friend void swap(EstablishSession& a, EstablishSession& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EstablishSession* New() const PROTOBUF_FINAL { return New(NULL); }

  EstablishSession* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const EstablishSession& from);
  void MergeFrom(const EstablishSession& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EstablishSession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef EstablishSession_SessionType SessionType;
  static const SessionType CONTROL_SESSION =
    EstablishSession_SessionType_CONTROL_SESSION;
  static const SessionType CONTENT_TRANSMISSION =
    EstablishSession_SessionType_CONTENT_TRANSMISSION;
  static inline bool SessionType_IsValid(int value) {
    return EstablishSession_SessionType_IsValid(value);
  }
  static const SessionType SessionType_MIN =
    EstablishSession_SessionType_SessionType_MIN;
  static const SessionType SessionType_MAX =
    EstablishSession_SessionType_SessionType_MAX;
  static const int SessionType_ARRAYSIZE =
    EstablishSession_SessionType_SessionType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional string previousSessionId = 3;
  bool has_previoussessionid() const;
  void clear_previoussessionid();
  static const int kPreviousSessionIdFieldNumber = 3;
  const ::std::string& previoussessionid() const;
  void set_previoussessionid(const ::std::string& value);
  #if LANG_CXX11
  void set_previoussessionid(::std::string&& value);
  #endif
  void set_previoussessionid(const char* value);
  void set_previoussessionid(const char* value, size_t size);
  ::std::string* mutable_previoussessionid();
  ::std::string* release_previoussessionid();
  void set_allocated_previoussessionid(::std::string* previoussessionid);

  // optional string clientVersion = 4;
  bool has_clientversion() const;
  void clear_clientversion();
  static const int kClientVersionFieldNumber = 4;
  const ::std::string& clientversion() const;
  void set_clientversion(const ::std::string& value);
  #if LANG_CXX11
  void set_clientversion(::std::string&& value);
  #endif
  void set_clientversion(const char* value);
  void set_clientversion(const char* value, size_t size);
  ::std::string* mutable_clientversion();
  ::std::string* release_clientversion();
  void set_allocated_clientversion(::std::string* clientversion);

  // optional string clientVersionHash = 5;
  bool has_clientversionhash() const;
  void clear_clientversionhash();
  static const int kClientVersionHashFieldNumber = 5;
  const ::std::string& clientversionhash() const;
  void set_clientversionhash(const ::std::string& value);
  #if LANG_CXX11
  void set_clientversionhash(::std::string&& value);
  #endif
  void set_clientversionhash(const char* value);
  void set_clientversionhash(const char* value, size_t size);
  ::std::string* mutable_clientversionhash();
  ::std::string* release_clientversionhash();
  void set_allocated_clientversionhash(::std::string* clientversionhash);

  // required .networkif.protoc.GeneralHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::networkif::protoc::GeneralHeader& header() const;
  ::networkif::protoc::GeneralHeader* release_header();
  ::networkif::protoc::GeneralHeader* mutable_header();
  void set_allocated_header(::networkif::protoc::GeneralHeader* header);

  // optional uint32 updateIntervalMin = 6;
  bool has_updateintervalmin() const;
  void clear_updateintervalmin();
  static const int kUpdateIntervalMinFieldNumber = 6;
  ::google::protobuf::uint32 updateintervalmin() const;
  void set_updateintervalmin(::google::protobuf::uint32 value);

  // optional uint32 heartbeatInterval = 7;
  bool has_heartbeatinterval() const;
  void clear_heartbeatinterval();
  static const int kHeartbeatIntervalFieldNumber = 7;
  ::google::protobuf::uint32 heartbeatinterval() const;
  void set_heartbeatinterval(::google::protobuf::uint32 value);

  // optional uint32 heartbeatLostThreshold = 8;
  bool has_heartbeatlostthreshold() const;
  void clear_heartbeatlostthreshold();
  static const int kHeartbeatLostThresholdFieldNumber = 8;
  ::google::protobuf::uint32 heartbeatlostthreshold() const;
  void set_heartbeatlostthreshold(::google::protobuf::uint32 value);

  // optional uint32 fileSizeThresholdInKB = 9;
  bool has_filesizethresholdinkb() const;
  void clear_filesizethresholdinkb();
  static const int kFileSizeThresholdInKBFieldNumber = 9;
  ::google::protobuf::uint32 filesizethresholdinkb() const;
  void set_filesizethresholdinkb(::google::protobuf::uint32 value);

  // required .networkif.protoc.EstablishSession.SessionType sessionType = 2;
  bool has_sessiontype() const;
  void clear_sessiontype();
  static const int kSessionTypeFieldNumber = 2;
  ::networkif::protoc::EstablishSession_SessionType sessiontype() const;
  void set_sessiontype(::networkif::protoc::EstablishSession_SessionType value);

  // @@protoc_insertion_point(class_scope:networkif.protoc.EstablishSession)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_sessiontype();
  void clear_has_sessiontype();
  void set_has_previoussessionid();
  void clear_has_previoussessionid();
  void set_has_clientversion();
  void clear_has_clientversion();
  void set_has_clientversionhash();
  void clear_has_clientversionhash();
  void set_has_updateintervalmin();
  void clear_has_updateintervalmin();
  void set_has_heartbeatinterval();
  void clear_has_heartbeatinterval();
  void set_has_heartbeatlostthreshold();
  void clear_has_heartbeatlostthreshold();
  void set_has_filesizethresholdinkb();
  void clear_has_filesizethresholdinkb();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr previoussessionid_;
  ::google::protobuf::internal::ArenaStringPtr clientversion_;
  ::google::protobuf::internal::ArenaStringPtr clientversionhash_;
  ::networkif::protoc::GeneralHeader* header_;
  ::google::protobuf::uint32 updateintervalmin_;
  ::google::protobuf::uint32 heartbeatinterval_;
  ::google::protobuf::uint32 heartbeatlostthreshold_;
  ::google::protobuf::uint32 filesizethresholdinkb_;
  int sessiontype_;
  friend struct ::protobuf_SessionManage_2eproto::TableStruct;
  friend void ::protobuf_SessionManage_2eproto::InitDefaultsEstablishSessionImpl();
};
// -------------------------------------------------------------------

class SessionEstablished_SuccessResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:networkif.protoc.SessionEstablished.SuccessResponse) */ {
 public:
  SessionEstablished_SuccessResponse();
  virtual ~SessionEstablished_SuccessResponse();

  SessionEstablished_SuccessResponse(const SessionEstablished_SuccessResponse& from);

  inline SessionEstablished_SuccessResponse& operator=(const SessionEstablished_SuccessResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SessionEstablished_SuccessResponse(SessionEstablished_SuccessResponse&& from) noexcept
    : SessionEstablished_SuccessResponse() {
    *this = ::std::move(from);
  }

  inline SessionEstablished_SuccessResponse& operator=(SessionEstablished_SuccessResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SessionEstablished_SuccessResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SessionEstablished_SuccessResponse* internal_default_instance() {
    return reinterpret_cast<const SessionEstablished_SuccessResponse*>(
               &_SessionEstablished_SuccessResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(SessionEstablished_SuccessResponse* other);
  friend void swap(SessionEstablished_SuccessResponse& a, SessionEstablished_SuccessResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SessionEstablished_SuccessResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  SessionEstablished_SuccessResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SessionEstablished_SuccessResponse& from);
  void MergeFrom(const SessionEstablished_SuccessResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SessionEstablished_SuccessResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string assignedSessionId = 1;
  bool has_assignedsessionid() const;
  void clear_assignedsessionid();
  static const int kAssignedSessionIdFieldNumber = 1;
  const ::std::string& assignedsessionid() const;
  void set_assignedsessionid(const ::std::string& value);
  #if LANG_CXX11
  void set_assignedsessionid(::std::string&& value);
  #endif
  void set_assignedsessionid(const char* value);
  void set_assignedsessionid(const char* value, size_t size);
  ::std::string* mutable_assignedsessionid();
  ::std::string* release_assignedsessionid();
  void set_allocated_assignedsessionid(::std::string* assignedsessionid);

  // required string sessionObjectDistname = 2;
  bool has_sessionobjectdistname() const;
  void clear_sessionobjectdistname();
  static const int kSessionObjectDistnameFieldNumber = 2;
  const ::std::string& sessionobjectdistname() const;
  void set_sessionobjectdistname(const ::std::string& value);
  #if LANG_CXX11
  void set_sessionobjectdistname(::std::string&& value);
  #endif
  void set_sessionobjectdistname(const char* value);
  void set_sessionobjectdistname(const char* value, size_t size);
  ::std::string* mutable_sessionobjectdistname();
  ::std::string* release_sessionobjectdistname();
  void set_allocated_sessionobjectdistname(::std::string* sessionobjectdistname);

  // optional string embeddedClientVersion = 3;
  bool has_embeddedclientversion() const;
  void clear_embeddedclientversion();
  static const int kEmbeddedClientVersionFieldNumber = 3;
  const ::std::string& embeddedclientversion() const;
  void set_embeddedclientversion(const ::std::string& value);
  #if LANG_CXX11
  void set_embeddedclientversion(::std::string&& value);
  #endif
  void set_embeddedclientversion(const char* value);
  void set_embeddedclientversion(const char* value, size_t size);
  ::std::string* mutable_embeddedclientversion();
  ::std::string* release_embeddedclientversion();
  void set_allocated_embeddedclientversion(::std::string* embeddedclientversion);

  // optional string embeddedClientVersionHash = 4;
  bool has_embeddedclientversionhash() const;
  void clear_embeddedclientversionhash();
  static const int kEmbeddedClientVersionHashFieldNumber = 4;
  const ::std::string& embeddedclientversionhash() const;
  void set_embeddedclientversionhash(const ::std::string& value);
  #if LANG_CXX11
  void set_embeddedclientversionhash(::std::string&& value);
  #endif
  void set_embeddedclientversionhash(const char* value);
  void set_embeddedclientversionhash(const char* value, size_t size);
  ::std::string* mutable_embeddedclientversionhash();
  ::std::string* release_embeddedclientversionhash();
  void set_allocated_embeddedclientversionhash(::std::string* embeddedclientversionhash);

  // optional uint32 updateIntervalMin = 5;
  bool has_updateintervalmin() const;
  void clear_updateintervalmin();
  static const int kUpdateIntervalMinFieldNumber = 5;
  ::google::protobuf::uint32 updateintervalmin() const;
  void set_updateintervalmin(::google::protobuf::uint32 value);

  // optional uint32 heartbeatInterval = 6;
  bool has_heartbeatinterval() const;
  void clear_heartbeatinterval();
  static const int kHeartbeatIntervalFieldNumber = 6;
  ::google::protobuf::uint32 heartbeatinterval() const;
  void set_heartbeatinterval(::google::protobuf::uint32 value);

  // optional uint32 heartbeatLostThreshold = 7;
  bool has_heartbeatlostthreshold() const;
  void clear_heartbeatlostthreshold();
  static const int kHeartbeatLostThresholdFieldNumber = 7;
  ::google::protobuf::uint32 heartbeatlostthreshold() const;
  void set_heartbeatlostthreshold(::google::protobuf::uint32 value);

  // optional uint32 fileSizeThresholdInKB = 8;
  bool has_filesizethresholdinkb() const;
  void clear_filesizethresholdinkb();
  static const int kFileSizeThresholdInKBFieldNumber = 8;
  ::google::protobuf::uint32 filesizethresholdinkb() const;
  void set_filesizethresholdinkb(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:networkif.protoc.SessionEstablished.SuccessResponse)
 private:
  void set_has_assignedsessionid();
  void clear_has_assignedsessionid();
  void set_has_sessionobjectdistname();
  void clear_has_sessionobjectdistname();
  void set_has_embeddedclientversion();
  void clear_has_embeddedclientversion();
  void set_has_embeddedclientversionhash();
  void clear_has_embeddedclientversionhash();
  void set_has_updateintervalmin();
  void clear_has_updateintervalmin();
  void set_has_heartbeatinterval();
  void clear_has_heartbeatinterval();
  void set_has_heartbeatlostthreshold();
  void clear_has_heartbeatlostthreshold();
  void set_has_filesizethresholdinkb();
  void clear_has_filesizethresholdinkb();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr assignedsessionid_;
  ::google::protobuf::internal::ArenaStringPtr sessionobjectdistname_;
  ::google::protobuf::internal::ArenaStringPtr embeddedclientversion_;
  ::google::protobuf::internal::ArenaStringPtr embeddedclientversionhash_;
  ::google::protobuf::uint32 updateintervalmin_;
  ::google::protobuf::uint32 heartbeatinterval_;
  ::google::protobuf::uint32 heartbeatlostthreshold_;
  ::google::protobuf::uint32 filesizethresholdinkb_;
  friend struct ::protobuf_SessionManage_2eproto::TableStruct;
  friend void ::protobuf_SessionManage_2eproto::InitDefaultsSessionEstablished_SuccessResponseImpl();
};
// -------------------------------------------------------------------

class SessionEstablished : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:networkif.protoc.SessionEstablished) */ {
 public:
  SessionEstablished();
  virtual ~SessionEstablished();

  SessionEstablished(const SessionEstablished& from);

  inline SessionEstablished& operator=(const SessionEstablished& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SessionEstablished(SessionEstablished&& from) noexcept
    : SessionEstablished() {
    *this = ::std::move(from);
  }

  inline SessionEstablished& operator=(SessionEstablished&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SessionEstablished& default_instance();

  enum ResponseDetailsCase {
    kSuccessResp = 3,
    kResultDescription = 4,
    RESPONSEDETAILS_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SessionEstablished* internal_default_instance() {
    return reinterpret_cast<const SessionEstablished*>(
               &_SessionEstablished_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(SessionEstablished* other);
  friend void swap(SessionEstablished& a, SessionEstablished& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SessionEstablished* New() const PROTOBUF_FINAL { return New(NULL); }

  SessionEstablished* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SessionEstablished& from);
  void MergeFrom(const SessionEstablished& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SessionEstablished* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SessionEstablished_SuccessResponse SuccessResponse;

  typedef SessionEstablished_SessionEstablishedResult SessionEstablishedResult;
  static const SessionEstablishedResult SUCCESS =
    SessionEstablished_SessionEstablishedResult_SUCCESS;
  static const SessionEstablishedResult INVALID_UNSPECIFIED =
    SessionEstablished_SessionEstablishedResult_INVALID_UNSPECIFIED;
  static const SessionEstablishedResult SESSIONS_LIMIT_EXCEEDED =
    SessionEstablished_SessionEstablishedResult_SESSIONS_LIMIT_EXCEEDED;
  static inline bool SessionEstablishedResult_IsValid(int value) {
    return SessionEstablished_SessionEstablishedResult_IsValid(value);
  }
  static const SessionEstablishedResult SessionEstablishedResult_MIN =
    SessionEstablished_SessionEstablishedResult_SessionEstablishedResult_MIN;
  static const SessionEstablishedResult SessionEstablishedResult_MAX =
    SessionEstablished_SessionEstablishedResult_SessionEstablishedResult_MAX;
  static const int SessionEstablishedResult_ARRAYSIZE =
    SessionEstablished_SessionEstablishedResult_SessionEstablishedResult_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .networkif.protoc.GeneralHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::networkif::protoc::GeneralHeader& header() const;
  ::networkif::protoc::GeneralHeader* release_header();
  ::networkif::protoc::GeneralHeader* mutable_header();
  void set_allocated_header(::networkif::protoc::GeneralHeader* header);

  // required .networkif.protoc.SessionEstablished.SessionEstablishedResult result = 2;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 2;
  ::networkif::protoc::SessionEstablished_SessionEstablishedResult result() const;
  void set_result(::networkif::protoc::SessionEstablished_SessionEstablishedResult value);

  // optional .networkif.protoc.SessionEstablished.SuccessResponse successResp = 3;
  bool has_successresp() const;
  void clear_successresp();
  static const int kSuccessRespFieldNumber = 3;
  const ::networkif::protoc::SessionEstablished_SuccessResponse& successresp() const;
  ::networkif::protoc::SessionEstablished_SuccessResponse* release_successresp();
  ::networkif::protoc::SessionEstablished_SuccessResponse* mutable_successresp();
  void set_allocated_successresp(::networkif::protoc::SessionEstablished_SuccessResponse* successresp);

  // optional string resultDescription = 4;
  bool has_resultdescription() const;
  void clear_resultdescription();
  static const int kResultDescriptionFieldNumber = 4;
  const ::std::string& resultdescription() const;
  void set_resultdescription(const ::std::string& value);
  #if LANG_CXX11
  void set_resultdescription(::std::string&& value);
  #endif
  void set_resultdescription(const char* value);
  void set_resultdescription(const char* value, size_t size);
  ::std::string* mutable_resultdescription();
  ::std::string* release_resultdescription();
  void set_allocated_resultdescription(::std::string* resultdescription);

  ResponseDetailsCase responseDetails_case() const;
  // @@protoc_insertion_point(class_scope:networkif.protoc.SessionEstablished)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_result();
  void clear_has_result();
  void set_has_successresp();
  void set_has_resultdescription();

  inline bool has_responseDetails() const;
  void clear_responseDetails();
  inline void clear_has_responseDetails();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::networkif::protoc::GeneralHeader* header_;
  int result_;
  union ResponseDetailsUnion {
    ResponseDetailsUnion() {}
    ::networkif::protoc::SessionEstablished_SuccessResponse* successresp_;
    ::google::protobuf::internal::ArenaStringPtr resultdescription_;
  } responseDetails_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_SessionManage_2eproto::TableStruct;
  friend void ::protobuf_SessionManage_2eproto::InitDefaultsSessionEstablishedImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EstablishSession

// required .networkif.protoc.GeneralHeader header = 1;
inline bool EstablishSession::has_header() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EstablishSession::set_has_header() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EstablishSession::clear_has_header() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::networkif::protoc::GeneralHeader& EstablishSession::header() const {
  const ::networkif::protoc::GeneralHeader* p = header_;
  // @@protoc_insertion_point(field_get:networkif.protoc.EstablishSession.header)
  return p != NULL ? *p : *reinterpret_cast<const ::networkif::protoc::GeneralHeader*>(
      &::networkif::protoc::_GeneralHeader_default_instance_);
}
inline ::networkif::protoc::GeneralHeader* EstablishSession::release_header() {
  // @@protoc_insertion_point(field_release:networkif.protoc.EstablishSession.header)
  clear_has_header();
  ::networkif::protoc::GeneralHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::networkif::protoc::GeneralHeader* EstablishSession::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::networkif::protoc::GeneralHeader;
  }
  // @@protoc_insertion_point(field_mutable:networkif.protoc.EstablishSession.header)
  return header_;
}
inline void EstablishSession::set_allocated_header(::networkif::protoc::GeneralHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:networkif.protoc.EstablishSession.header)
}

// required .networkif.protoc.EstablishSession.SessionType sessionType = 2;
inline bool EstablishSession::has_sessiontype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EstablishSession::set_has_sessiontype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EstablishSession::clear_has_sessiontype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EstablishSession::clear_sessiontype() {
  sessiontype_ = 1;
  clear_has_sessiontype();
}
inline ::networkif::protoc::EstablishSession_SessionType EstablishSession::sessiontype() const {
  // @@protoc_insertion_point(field_get:networkif.protoc.EstablishSession.sessionType)
  return static_cast< ::networkif::protoc::EstablishSession_SessionType >(sessiontype_);
}
inline void EstablishSession::set_sessiontype(::networkif::protoc::EstablishSession_SessionType value) {
  assert(::networkif::protoc::EstablishSession_SessionType_IsValid(value));
  set_has_sessiontype();
  sessiontype_ = value;
  // @@protoc_insertion_point(field_set:networkif.protoc.EstablishSession.sessionType)
}

// optional string previousSessionId = 3;
inline bool EstablishSession::has_previoussessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EstablishSession::set_has_previoussessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EstablishSession::clear_has_previoussessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EstablishSession::clear_previoussessionid() {
  previoussessionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_previoussessionid();
}
inline const ::std::string& EstablishSession::previoussessionid() const {
  // @@protoc_insertion_point(field_get:networkif.protoc.EstablishSession.previousSessionId)
  return previoussessionid_.GetNoArena();
}
inline void EstablishSession::set_previoussessionid(const ::std::string& value) {
  set_has_previoussessionid();
  previoussessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:networkif.protoc.EstablishSession.previousSessionId)
}
#if LANG_CXX11
inline void EstablishSession::set_previoussessionid(::std::string&& value) {
  set_has_previoussessionid();
  previoussessionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:networkif.protoc.EstablishSession.previousSessionId)
}
#endif
inline void EstablishSession::set_previoussessionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_previoussessionid();
  previoussessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:networkif.protoc.EstablishSession.previousSessionId)
}
inline void EstablishSession::set_previoussessionid(const char* value, size_t size) {
  set_has_previoussessionid();
  previoussessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:networkif.protoc.EstablishSession.previousSessionId)
}
inline ::std::string* EstablishSession::mutable_previoussessionid() {
  set_has_previoussessionid();
  // @@protoc_insertion_point(field_mutable:networkif.protoc.EstablishSession.previousSessionId)
  return previoussessionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EstablishSession::release_previoussessionid() {
  // @@protoc_insertion_point(field_release:networkif.protoc.EstablishSession.previousSessionId)
  clear_has_previoussessionid();
  return previoussessionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EstablishSession::set_allocated_previoussessionid(::std::string* previoussessionid) {
  if (previoussessionid != NULL) {
    set_has_previoussessionid();
  } else {
    clear_has_previoussessionid();
  }
  previoussessionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), previoussessionid);
  // @@protoc_insertion_point(field_set_allocated:networkif.protoc.EstablishSession.previousSessionId)
}

// optional string clientVersion = 4;
inline bool EstablishSession::has_clientversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EstablishSession::set_has_clientversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EstablishSession::clear_has_clientversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EstablishSession::clear_clientversion() {
  clientversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientversion();
}
inline const ::std::string& EstablishSession::clientversion() const {
  // @@protoc_insertion_point(field_get:networkif.protoc.EstablishSession.clientVersion)
  return clientversion_.GetNoArena();
}
inline void EstablishSession::set_clientversion(const ::std::string& value) {
  set_has_clientversion();
  clientversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:networkif.protoc.EstablishSession.clientVersion)
}
#if LANG_CXX11
inline void EstablishSession::set_clientversion(::std::string&& value) {
  set_has_clientversion();
  clientversion_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:networkif.protoc.EstablishSession.clientVersion)
}
#endif
inline void EstablishSession::set_clientversion(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientversion();
  clientversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:networkif.protoc.EstablishSession.clientVersion)
}
inline void EstablishSession::set_clientversion(const char* value, size_t size) {
  set_has_clientversion();
  clientversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:networkif.protoc.EstablishSession.clientVersion)
}
inline ::std::string* EstablishSession::mutable_clientversion() {
  set_has_clientversion();
  // @@protoc_insertion_point(field_mutable:networkif.protoc.EstablishSession.clientVersion)
  return clientversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EstablishSession::release_clientversion() {
  // @@protoc_insertion_point(field_release:networkif.protoc.EstablishSession.clientVersion)
  clear_has_clientversion();
  return clientversion_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EstablishSession::set_allocated_clientversion(::std::string* clientversion) {
  if (clientversion != NULL) {
    set_has_clientversion();
  } else {
    clear_has_clientversion();
  }
  clientversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientversion);
  // @@protoc_insertion_point(field_set_allocated:networkif.protoc.EstablishSession.clientVersion)
}

// optional string clientVersionHash = 5;
inline bool EstablishSession::has_clientversionhash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EstablishSession::set_has_clientversionhash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EstablishSession::clear_has_clientversionhash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EstablishSession::clear_clientversionhash() {
  clientversionhash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientversionhash();
}
inline const ::std::string& EstablishSession::clientversionhash() const {
  // @@protoc_insertion_point(field_get:networkif.protoc.EstablishSession.clientVersionHash)
  return clientversionhash_.GetNoArena();
}
inline void EstablishSession::set_clientversionhash(const ::std::string& value) {
  set_has_clientversionhash();
  clientversionhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:networkif.protoc.EstablishSession.clientVersionHash)
}
#if LANG_CXX11
inline void EstablishSession::set_clientversionhash(::std::string&& value) {
  set_has_clientversionhash();
  clientversionhash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:networkif.protoc.EstablishSession.clientVersionHash)
}
#endif
inline void EstablishSession::set_clientversionhash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientversionhash();
  clientversionhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:networkif.protoc.EstablishSession.clientVersionHash)
}
inline void EstablishSession::set_clientversionhash(const char* value, size_t size) {
  set_has_clientversionhash();
  clientversionhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:networkif.protoc.EstablishSession.clientVersionHash)
}
inline ::std::string* EstablishSession::mutable_clientversionhash() {
  set_has_clientversionhash();
  // @@protoc_insertion_point(field_mutable:networkif.protoc.EstablishSession.clientVersionHash)
  return clientversionhash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EstablishSession::release_clientversionhash() {
  // @@protoc_insertion_point(field_release:networkif.protoc.EstablishSession.clientVersionHash)
  clear_has_clientversionhash();
  return clientversionhash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EstablishSession::set_allocated_clientversionhash(::std::string* clientversionhash) {
  if (clientversionhash != NULL) {
    set_has_clientversionhash();
  } else {
    clear_has_clientversionhash();
  }
  clientversionhash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientversionhash);
  // @@protoc_insertion_point(field_set_allocated:networkif.protoc.EstablishSession.clientVersionHash)
}

// optional uint32 updateIntervalMin = 6;
inline bool EstablishSession::has_updateintervalmin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EstablishSession::set_has_updateintervalmin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EstablishSession::clear_has_updateintervalmin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EstablishSession::clear_updateintervalmin() {
  updateintervalmin_ = 0u;
  clear_has_updateintervalmin();
}
inline ::google::protobuf::uint32 EstablishSession::updateintervalmin() const {
  // @@protoc_insertion_point(field_get:networkif.protoc.EstablishSession.updateIntervalMin)
  return updateintervalmin_;
}
inline void EstablishSession::set_updateintervalmin(::google::protobuf::uint32 value) {
  set_has_updateintervalmin();
  updateintervalmin_ = value;
  // @@protoc_insertion_point(field_set:networkif.protoc.EstablishSession.updateIntervalMin)
}

// optional uint32 heartbeatInterval = 7;
inline bool EstablishSession::has_heartbeatinterval() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EstablishSession::set_has_heartbeatinterval() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EstablishSession::clear_has_heartbeatinterval() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EstablishSession::clear_heartbeatinterval() {
  heartbeatinterval_ = 0u;
  clear_has_heartbeatinterval();
}
inline ::google::protobuf::uint32 EstablishSession::heartbeatinterval() const {
  // @@protoc_insertion_point(field_get:networkif.protoc.EstablishSession.heartbeatInterval)
  return heartbeatinterval_;
}
inline void EstablishSession::set_heartbeatinterval(::google::protobuf::uint32 value) {
  set_has_heartbeatinterval();
  heartbeatinterval_ = value;
  // @@protoc_insertion_point(field_set:networkif.protoc.EstablishSession.heartbeatInterval)
}

// optional uint32 heartbeatLostThreshold = 8;
inline bool EstablishSession::has_heartbeatlostthreshold() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EstablishSession::set_has_heartbeatlostthreshold() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EstablishSession::clear_has_heartbeatlostthreshold() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EstablishSession::clear_heartbeatlostthreshold() {
  heartbeatlostthreshold_ = 0u;
  clear_has_heartbeatlostthreshold();
}
inline ::google::protobuf::uint32 EstablishSession::heartbeatlostthreshold() const {
  // @@protoc_insertion_point(field_get:networkif.protoc.EstablishSession.heartbeatLostThreshold)
  return heartbeatlostthreshold_;
}
inline void EstablishSession::set_heartbeatlostthreshold(::google::protobuf::uint32 value) {
  set_has_heartbeatlostthreshold();
  heartbeatlostthreshold_ = value;
  // @@protoc_insertion_point(field_set:networkif.protoc.EstablishSession.heartbeatLostThreshold)
}

// optional uint32 fileSizeThresholdInKB = 9;
inline bool EstablishSession::has_filesizethresholdinkb() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EstablishSession::set_has_filesizethresholdinkb() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EstablishSession::clear_has_filesizethresholdinkb() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EstablishSession::clear_filesizethresholdinkb() {
  filesizethresholdinkb_ = 0u;
  clear_has_filesizethresholdinkb();
}
inline ::google::protobuf::uint32 EstablishSession::filesizethresholdinkb() const {
  // @@protoc_insertion_point(field_get:networkif.protoc.EstablishSession.fileSizeThresholdInKB)
  return filesizethresholdinkb_;
}
inline void EstablishSession::set_filesizethresholdinkb(::google::protobuf::uint32 value) {
  set_has_filesizethresholdinkb();
  filesizethresholdinkb_ = value;
  // @@protoc_insertion_point(field_set:networkif.protoc.EstablishSession.fileSizeThresholdInKB)
}

// -------------------------------------------------------------------

// SessionEstablished_SuccessResponse

// required string assignedSessionId = 1;
inline bool SessionEstablished_SuccessResponse::has_assignedsessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionEstablished_SuccessResponse::set_has_assignedsessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionEstablished_SuccessResponse::clear_has_assignedsessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionEstablished_SuccessResponse::clear_assignedsessionid() {
  assignedsessionid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_assignedsessionid();
}
inline const ::std::string& SessionEstablished_SuccessResponse::assignedsessionid() const {
  // @@protoc_insertion_point(field_get:networkif.protoc.SessionEstablished.SuccessResponse.assignedSessionId)
  return assignedsessionid_.GetNoArena();
}
inline void SessionEstablished_SuccessResponse::set_assignedsessionid(const ::std::string& value) {
  set_has_assignedsessionid();
  assignedsessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:networkif.protoc.SessionEstablished.SuccessResponse.assignedSessionId)
}
#if LANG_CXX11
inline void SessionEstablished_SuccessResponse::set_assignedsessionid(::std::string&& value) {
  set_has_assignedsessionid();
  assignedsessionid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:networkif.protoc.SessionEstablished.SuccessResponse.assignedSessionId)
}
#endif
inline void SessionEstablished_SuccessResponse::set_assignedsessionid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_assignedsessionid();
  assignedsessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:networkif.protoc.SessionEstablished.SuccessResponse.assignedSessionId)
}
inline void SessionEstablished_SuccessResponse::set_assignedsessionid(const char* value, size_t size) {
  set_has_assignedsessionid();
  assignedsessionid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:networkif.protoc.SessionEstablished.SuccessResponse.assignedSessionId)
}
inline ::std::string* SessionEstablished_SuccessResponse::mutable_assignedsessionid() {
  set_has_assignedsessionid();
  // @@protoc_insertion_point(field_mutable:networkif.protoc.SessionEstablished.SuccessResponse.assignedSessionId)
  return assignedsessionid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionEstablished_SuccessResponse::release_assignedsessionid() {
  // @@protoc_insertion_point(field_release:networkif.protoc.SessionEstablished.SuccessResponse.assignedSessionId)
  clear_has_assignedsessionid();
  return assignedsessionid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionEstablished_SuccessResponse::set_allocated_assignedsessionid(::std::string* assignedsessionid) {
  if (assignedsessionid != NULL) {
    set_has_assignedsessionid();
  } else {
    clear_has_assignedsessionid();
  }
  assignedsessionid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), assignedsessionid);
  // @@protoc_insertion_point(field_set_allocated:networkif.protoc.SessionEstablished.SuccessResponse.assignedSessionId)
}

// required string sessionObjectDistname = 2;
inline bool SessionEstablished_SuccessResponse::has_sessionobjectdistname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionEstablished_SuccessResponse::set_has_sessionobjectdistname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SessionEstablished_SuccessResponse::clear_has_sessionobjectdistname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SessionEstablished_SuccessResponse::clear_sessionobjectdistname() {
  sessionobjectdistname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sessionobjectdistname();
}
inline const ::std::string& SessionEstablished_SuccessResponse::sessionobjectdistname() const {
  // @@protoc_insertion_point(field_get:networkif.protoc.SessionEstablished.SuccessResponse.sessionObjectDistname)
  return sessionobjectdistname_.GetNoArena();
}
inline void SessionEstablished_SuccessResponse::set_sessionobjectdistname(const ::std::string& value) {
  set_has_sessionobjectdistname();
  sessionobjectdistname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:networkif.protoc.SessionEstablished.SuccessResponse.sessionObjectDistname)
}
#if LANG_CXX11
inline void SessionEstablished_SuccessResponse::set_sessionobjectdistname(::std::string&& value) {
  set_has_sessionobjectdistname();
  sessionobjectdistname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:networkif.protoc.SessionEstablished.SuccessResponse.sessionObjectDistname)
}
#endif
inline void SessionEstablished_SuccessResponse::set_sessionobjectdistname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sessionobjectdistname();
  sessionobjectdistname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:networkif.protoc.SessionEstablished.SuccessResponse.sessionObjectDistname)
}
inline void SessionEstablished_SuccessResponse::set_sessionobjectdistname(const char* value, size_t size) {
  set_has_sessionobjectdistname();
  sessionobjectdistname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:networkif.protoc.SessionEstablished.SuccessResponse.sessionObjectDistname)
}
inline ::std::string* SessionEstablished_SuccessResponse::mutable_sessionobjectdistname() {
  set_has_sessionobjectdistname();
  // @@protoc_insertion_point(field_mutable:networkif.protoc.SessionEstablished.SuccessResponse.sessionObjectDistname)
  return sessionobjectdistname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionEstablished_SuccessResponse::release_sessionobjectdistname() {
  // @@protoc_insertion_point(field_release:networkif.protoc.SessionEstablished.SuccessResponse.sessionObjectDistname)
  clear_has_sessionobjectdistname();
  return sessionobjectdistname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionEstablished_SuccessResponse::set_allocated_sessionobjectdistname(::std::string* sessionobjectdistname) {
  if (sessionobjectdistname != NULL) {
    set_has_sessionobjectdistname();
  } else {
    clear_has_sessionobjectdistname();
  }
  sessionobjectdistname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sessionobjectdistname);
  // @@protoc_insertion_point(field_set_allocated:networkif.protoc.SessionEstablished.SuccessResponse.sessionObjectDistname)
}

// optional string embeddedClientVersion = 3;
inline bool SessionEstablished_SuccessResponse::has_embeddedclientversion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SessionEstablished_SuccessResponse::set_has_embeddedclientversion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SessionEstablished_SuccessResponse::clear_has_embeddedclientversion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SessionEstablished_SuccessResponse::clear_embeddedclientversion() {
  embeddedclientversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_embeddedclientversion();
}
inline const ::std::string& SessionEstablished_SuccessResponse::embeddedclientversion() const {
  // @@protoc_insertion_point(field_get:networkif.protoc.SessionEstablished.SuccessResponse.embeddedClientVersion)
  return embeddedclientversion_.GetNoArena();
}
inline void SessionEstablished_SuccessResponse::set_embeddedclientversion(const ::std::string& value) {
  set_has_embeddedclientversion();
  embeddedclientversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:networkif.protoc.SessionEstablished.SuccessResponse.embeddedClientVersion)
}
#if LANG_CXX11
inline void SessionEstablished_SuccessResponse::set_embeddedclientversion(::std::string&& value) {
  set_has_embeddedclientversion();
  embeddedclientversion_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:networkif.protoc.SessionEstablished.SuccessResponse.embeddedClientVersion)
}
#endif
inline void SessionEstablished_SuccessResponse::set_embeddedclientversion(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_embeddedclientversion();
  embeddedclientversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:networkif.protoc.SessionEstablished.SuccessResponse.embeddedClientVersion)
}
inline void SessionEstablished_SuccessResponse::set_embeddedclientversion(const char* value, size_t size) {
  set_has_embeddedclientversion();
  embeddedclientversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:networkif.protoc.SessionEstablished.SuccessResponse.embeddedClientVersion)
}
inline ::std::string* SessionEstablished_SuccessResponse::mutable_embeddedclientversion() {
  set_has_embeddedclientversion();
  // @@protoc_insertion_point(field_mutable:networkif.protoc.SessionEstablished.SuccessResponse.embeddedClientVersion)
  return embeddedclientversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionEstablished_SuccessResponse::release_embeddedclientversion() {
  // @@protoc_insertion_point(field_release:networkif.protoc.SessionEstablished.SuccessResponse.embeddedClientVersion)
  clear_has_embeddedclientversion();
  return embeddedclientversion_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionEstablished_SuccessResponse::set_allocated_embeddedclientversion(::std::string* embeddedclientversion) {
  if (embeddedclientversion != NULL) {
    set_has_embeddedclientversion();
  } else {
    clear_has_embeddedclientversion();
  }
  embeddedclientversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), embeddedclientversion);
  // @@protoc_insertion_point(field_set_allocated:networkif.protoc.SessionEstablished.SuccessResponse.embeddedClientVersion)
}

// optional string embeddedClientVersionHash = 4;
inline bool SessionEstablished_SuccessResponse::has_embeddedclientversionhash() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SessionEstablished_SuccessResponse::set_has_embeddedclientversionhash() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SessionEstablished_SuccessResponse::clear_has_embeddedclientversionhash() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SessionEstablished_SuccessResponse::clear_embeddedclientversionhash() {
  embeddedclientversionhash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_embeddedclientversionhash();
}
inline const ::std::string& SessionEstablished_SuccessResponse::embeddedclientversionhash() const {
  // @@protoc_insertion_point(field_get:networkif.protoc.SessionEstablished.SuccessResponse.embeddedClientVersionHash)
  return embeddedclientversionhash_.GetNoArena();
}
inline void SessionEstablished_SuccessResponse::set_embeddedclientversionhash(const ::std::string& value) {
  set_has_embeddedclientversionhash();
  embeddedclientversionhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:networkif.protoc.SessionEstablished.SuccessResponse.embeddedClientVersionHash)
}
#if LANG_CXX11
inline void SessionEstablished_SuccessResponse::set_embeddedclientversionhash(::std::string&& value) {
  set_has_embeddedclientversionhash();
  embeddedclientversionhash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:networkif.protoc.SessionEstablished.SuccessResponse.embeddedClientVersionHash)
}
#endif
inline void SessionEstablished_SuccessResponse::set_embeddedclientversionhash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_embeddedclientversionhash();
  embeddedclientversionhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:networkif.protoc.SessionEstablished.SuccessResponse.embeddedClientVersionHash)
}
inline void SessionEstablished_SuccessResponse::set_embeddedclientversionhash(const char* value, size_t size) {
  set_has_embeddedclientversionhash();
  embeddedclientversionhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:networkif.protoc.SessionEstablished.SuccessResponse.embeddedClientVersionHash)
}
inline ::std::string* SessionEstablished_SuccessResponse::mutable_embeddedclientversionhash() {
  set_has_embeddedclientversionhash();
  // @@protoc_insertion_point(field_mutable:networkif.protoc.SessionEstablished.SuccessResponse.embeddedClientVersionHash)
  return embeddedclientversionhash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionEstablished_SuccessResponse::release_embeddedclientversionhash() {
  // @@protoc_insertion_point(field_release:networkif.protoc.SessionEstablished.SuccessResponse.embeddedClientVersionHash)
  clear_has_embeddedclientversionhash();
  return embeddedclientversionhash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionEstablished_SuccessResponse::set_allocated_embeddedclientversionhash(::std::string* embeddedclientversionhash) {
  if (embeddedclientversionhash != NULL) {
    set_has_embeddedclientversionhash();
  } else {
    clear_has_embeddedclientversionhash();
  }
  embeddedclientversionhash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), embeddedclientversionhash);
  // @@protoc_insertion_point(field_set_allocated:networkif.protoc.SessionEstablished.SuccessResponse.embeddedClientVersionHash)
}

// optional uint32 updateIntervalMin = 5;
inline bool SessionEstablished_SuccessResponse::has_updateintervalmin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SessionEstablished_SuccessResponse::set_has_updateintervalmin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SessionEstablished_SuccessResponse::clear_has_updateintervalmin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SessionEstablished_SuccessResponse::clear_updateintervalmin() {
  updateintervalmin_ = 0u;
  clear_has_updateintervalmin();
}
inline ::google::protobuf::uint32 SessionEstablished_SuccessResponse::updateintervalmin() const {
  // @@protoc_insertion_point(field_get:networkif.protoc.SessionEstablished.SuccessResponse.updateIntervalMin)
  return updateintervalmin_;
}
inline void SessionEstablished_SuccessResponse::set_updateintervalmin(::google::protobuf::uint32 value) {
  set_has_updateintervalmin();
  updateintervalmin_ = value;
  // @@protoc_insertion_point(field_set:networkif.protoc.SessionEstablished.SuccessResponse.updateIntervalMin)
}

// optional uint32 heartbeatInterval = 6;
inline bool SessionEstablished_SuccessResponse::has_heartbeatinterval() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SessionEstablished_SuccessResponse::set_has_heartbeatinterval() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SessionEstablished_SuccessResponse::clear_has_heartbeatinterval() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SessionEstablished_SuccessResponse::clear_heartbeatinterval() {
  heartbeatinterval_ = 0u;
  clear_has_heartbeatinterval();
}
inline ::google::protobuf::uint32 SessionEstablished_SuccessResponse::heartbeatinterval() const {
  // @@protoc_insertion_point(field_get:networkif.protoc.SessionEstablished.SuccessResponse.heartbeatInterval)
  return heartbeatinterval_;
}
inline void SessionEstablished_SuccessResponse::set_heartbeatinterval(::google::protobuf::uint32 value) {
  set_has_heartbeatinterval();
  heartbeatinterval_ = value;
  // @@protoc_insertion_point(field_set:networkif.protoc.SessionEstablished.SuccessResponse.heartbeatInterval)
}

// optional uint32 heartbeatLostThreshold = 7;
inline bool SessionEstablished_SuccessResponse::has_heartbeatlostthreshold() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SessionEstablished_SuccessResponse::set_has_heartbeatlostthreshold() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SessionEstablished_SuccessResponse::clear_has_heartbeatlostthreshold() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SessionEstablished_SuccessResponse::clear_heartbeatlostthreshold() {
  heartbeatlostthreshold_ = 0u;
  clear_has_heartbeatlostthreshold();
}
inline ::google::protobuf::uint32 SessionEstablished_SuccessResponse::heartbeatlostthreshold() const {
  // @@protoc_insertion_point(field_get:networkif.protoc.SessionEstablished.SuccessResponse.heartbeatLostThreshold)
  return heartbeatlostthreshold_;
}
inline void SessionEstablished_SuccessResponse::set_heartbeatlostthreshold(::google::protobuf::uint32 value) {
  set_has_heartbeatlostthreshold();
  heartbeatlostthreshold_ = value;
  // @@protoc_insertion_point(field_set:networkif.protoc.SessionEstablished.SuccessResponse.heartbeatLostThreshold)
}

// optional uint32 fileSizeThresholdInKB = 8;
inline bool SessionEstablished_SuccessResponse::has_filesizethresholdinkb() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SessionEstablished_SuccessResponse::set_has_filesizethresholdinkb() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SessionEstablished_SuccessResponse::clear_has_filesizethresholdinkb() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SessionEstablished_SuccessResponse::clear_filesizethresholdinkb() {
  filesizethresholdinkb_ = 0u;
  clear_has_filesizethresholdinkb();
}
inline ::google::protobuf::uint32 SessionEstablished_SuccessResponse::filesizethresholdinkb() const {
  // @@protoc_insertion_point(field_get:networkif.protoc.SessionEstablished.SuccessResponse.fileSizeThresholdInKB)
  return filesizethresholdinkb_;
}
inline void SessionEstablished_SuccessResponse::set_filesizethresholdinkb(::google::protobuf::uint32 value) {
  set_has_filesizethresholdinkb();
  filesizethresholdinkb_ = value;
  // @@protoc_insertion_point(field_set:networkif.protoc.SessionEstablished.SuccessResponse.fileSizeThresholdInKB)
}

// -------------------------------------------------------------------

// SessionEstablished

// required .networkif.protoc.GeneralHeader header = 1;
inline bool SessionEstablished::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionEstablished::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionEstablished::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::networkif::protoc::GeneralHeader& SessionEstablished::header() const {
  const ::networkif::protoc::GeneralHeader* p = header_;
  // @@protoc_insertion_point(field_get:networkif.protoc.SessionEstablished.header)
  return p != NULL ? *p : *reinterpret_cast<const ::networkif::protoc::GeneralHeader*>(
      &::networkif::protoc::_GeneralHeader_default_instance_);
}
inline ::networkif::protoc::GeneralHeader* SessionEstablished::release_header() {
  // @@protoc_insertion_point(field_release:networkif.protoc.SessionEstablished.header)
  clear_has_header();
  ::networkif::protoc::GeneralHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::networkif::protoc::GeneralHeader* SessionEstablished::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::networkif::protoc::GeneralHeader;
  }
  // @@protoc_insertion_point(field_mutable:networkif.protoc.SessionEstablished.header)
  return header_;
}
inline void SessionEstablished::set_allocated_header(::networkif::protoc::GeneralHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:networkif.protoc.SessionEstablished.header)
}

// required .networkif.protoc.SessionEstablished.SessionEstablishedResult result = 2;
inline bool SessionEstablished::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionEstablished::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SessionEstablished::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SessionEstablished::clear_result() {
  result_ = 1;
  clear_has_result();
}
inline ::networkif::protoc::SessionEstablished_SessionEstablishedResult SessionEstablished::result() const {
  // @@protoc_insertion_point(field_get:networkif.protoc.SessionEstablished.result)
  return static_cast< ::networkif::protoc::SessionEstablished_SessionEstablishedResult >(result_);
}
inline void SessionEstablished::set_result(::networkif::protoc::SessionEstablished_SessionEstablishedResult value) {
  assert(::networkif::protoc::SessionEstablished_SessionEstablishedResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:networkif.protoc.SessionEstablished.result)
}

// optional .networkif.protoc.SessionEstablished.SuccessResponse successResp = 3;
inline bool SessionEstablished::has_successresp() const {
  return responseDetails_case() == kSuccessResp;
}
inline void SessionEstablished::set_has_successresp() {
  _oneof_case_[0] = kSuccessResp;
}
inline void SessionEstablished::clear_successresp() {
  if (has_successresp()) {
    delete responseDetails_.successresp_;
    clear_has_responseDetails();
  }
}
inline ::networkif::protoc::SessionEstablished_SuccessResponse* SessionEstablished::release_successresp() {
  // @@protoc_insertion_point(field_release:networkif.protoc.SessionEstablished.successResp)
  if (has_successresp()) {
    clear_has_responseDetails();
      ::networkif::protoc::SessionEstablished_SuccessResponse* temp = responseDetails_.successresp_;
    responseDetails_.successresp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::networkif::protoc::SessionEstablished_SuccessResponse& SessionEstablished::successresp() const {
  // @@protoc_insertion_point(field_get:networkif.protoc.SessionEstablished.successResp)
  return has_successresp()
      ? *responseDetails_.successresp_
      : *reinterpret_cast< ::networkif::protoc::SessionEstablished_SuccessResponse*>(&::networkif::protoc::_SessionEstablished_SuccessResponse_default_instance_);
}
inline ::networkif::protoc::SessionEstablished_SuccessResponse* SessionEstablished::mutable_successresp() {
  if (!has_successresp()) {
    clear_responseDetails();
    set_has_successresp();
    responseDetails_.successresp_ = new ::networkif::protoc::SessionEstablished_SuccessResponse;
  }
  // @@protoc_insertion_point(field_mutable:networkif.protoc.SessionEstablished.successResp)
  return responseDetails_.successresp_;
}

// optional string resultDescription = 4;
inline bool SessionEstablished::has_resultdescription() const {
  return responseDetails_case() == kResultDescription;
}
inline void SessionEstablished::set_has_resultdescription() {
  _oneof_case_[0] = kResultDescription;
}
inline void SessionEstablished::clear_resultdescription() {
  if (has_resultdescription()) {
    responseDetails_.resultdescription_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_responseDetails();
  }
}
inline const ::std::string& SessionEstablished::resultdescription() const {
  // @@protoc_insertion_point(field_get:networkif.protoc.SessionEstablished.resultDescription)
  if (has_resultdescription()) {
    return responseDetails_.resultdescription_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void SessionEstablished::set_resultdescription(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:networkif.protoc.SessionEstablished.resultDescription)
  if (!has_resultdescription()) {
    clear_responseDetails();
    set_has_resultdescription();
    responseDetails_.resultdescription_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  responseDetails_.resultdescription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:networkif.protoc.SessionEstablished.resultDescription)
}
#if LANG_CXX11
inline void SessionEstablished::set_resultdescription(::std::string&& value) {
  // @@protoc_insertion_point(field_set:networkif.protoc.SessionEstablished.resultDescription)
  if (!has_resultdescription()) {
    clear_responseDetails();
    set_has_resultdescription();
    responseDetails_.resultdescription_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  responseDetails_.resultdescription_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:networkif.protoc.SessionEstablished.resultDescription)
}
#endif
inline void SessionEstablished::set_resultdescription(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_resultdescription()) {
    clear_responseDetails();
    set_has_resultdescription();
    responseDetails_.resultdescription_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  responseDetails_.resultdescription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:networkif.protoc.SessionEstablished.resultDescription)
}
inline void SessionEstablished::set_resultdescription(const char* value, size_t size) {
  if (!has_resultdescription()) {
    clear_responseDetails();
    set_has_resultdescription();
    responseDetails_.resultdescription_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  responseDetails_.resultdescription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:networkif.protoc.SessionEstablished.resultDescription)
}
inline ::std::string* SessionEstablished::mutable_resultdescription() {
  if (!has_resultdescription()) {
    clear_responseDetails();
    set_has_resultdescription();
    responseDetails_.resultdescription_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:networkif.protoc.SessionEstablished.resultDescription)
  return responseDetails_.resultdescription_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionEstablished::release_resultdescription() {
  // @@protoc_insertion_point(field_release:networkif.protoc.SessionEstablished.resultDescription)
  if (has_resultdescription()) {
    clear_has_responseDetails();
    return responseDetails_.resultdescription_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void SessionEstablished::set_allocated_resultdescription(::std::string* resultdescription) {
  if (!has_resultdescription()) {
    responseDetails_.resultdescription_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_responseDetails();
  if (resultdescription != NULL) {
    set_has_resultdescription();
    responseDetails_.resultdescription_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        resultdescription);
  }
  // @@protoc_insertion_point(field_set_allocated:networkif.protoc.SessionEstablished.resultDescription)
}

inline bool SessionEstablished::has_responseDetails() const {
  return responseDetails_case() != RESPONSEDETAILS_NOT_SET;
}
inline void SessionEstablished::clear_has_responseDetails() {
  _oneof_case_[0] = RESPONSEDETAILS_NOT_SET;
}
inline SessionEstablished::ResponseDetailsCase SessionEstablished::responseDetails_case() const {
  return SessionEstablished::ResponseDetailsCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protoc
}  // namespace networkif

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::networkif::protoc::EstablishSession_SessionType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::networkif::protoc::SessionEstablished_SessionEstablishedResult> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SessionManage_2eproto__INCLUDED
