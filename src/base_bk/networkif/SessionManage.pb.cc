// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SessionManage.proto

#include "SessionManage.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)
namespace networkif {
namespace protoc {
class EstablishSessionDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EstablishSession>
      _instance;
} _EstablishSession_default_instance_;
class SessionEstablished_SuccessResponseDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SessionEstablished_SuccessResponse>
      _instance;
} _SessionEstablished_SuccessResponse_default_instance_;
class SessionEstablishedDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<SessionEstablished>
      _instance;
  const ::networkif::protoc::SessionEstablished_SuccessResponse* successresp_;
  ::google::protobuf::internal::ArenaStringPtr resultdescription_;
} _SessionEstablished_default_instance_;
}  // namespace protoc
}  // namespace networkif
namespace protobuf_SessionManage_2eproto {
void InitDefaultsEstablishSessionImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_GeneralHeader_2eproto::InitDefaultsGeneralHeader();
  {
    void* ptr = &::networkif::protoc::_EstablishSession_default_instance_;
    new (ptr) ::networkif::protoc::EstablishSession();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::networkif::protoc::EstablishSession::InitAsDefaultInstance();
}

void InitDefaultsEstablishSession() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsEstablishSessionImpl);
}

void InitDefaultsSessionEstablished_SuccessResponseImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::networkif::protoc::_SessionEstablished_SuccessResponse_default_instance_;
    new (ptr) ::networkif::protoc::SessionEstablished_SuccessResponse();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::networkif::protoc::SessionEstablished_SuccessResponse::InitAsDefaultInstance();
}

void InitDefaultsSessionEstablished_SuccessResponse() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsSessionEstablished_SuccessResponseImpl);
}

void InitDefaultsSessionEstablishedImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_GeneralHeader_2eproto::InitDefaultsGeneralHeader();
  protobuf_SessionManage_2eproto::InitDefaultsSessionEstablished_SuccessResponse();
  {
    void* ptr = &::networkif::protoc::_SessionEstablished_default_instance_;
    new (ptr) ::networkif::protoc::SessionEstablished();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::networkif::protoc::SessionEstablished::InitAsDefaultInstance();
}

void InitDefaultsSessionEstablished() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsSessionEstablishedImpl);
}

}  // namespace protobuf_SessionManage_2eproto
namespace networkif {
namespace protoc {
bool EstablishSession_SessionType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const EstablishSession_SessionType EstablishSession::CONTROL_SESSION;
const EstablishSession_SessionType EstablishSession::CONTENT_TRANSMISSION;
const EstablishSession_SessionType EstablishSession::SessionType_MIN;
const EstablishSession_SessionType EstablishSession::SessionType_MAX;
const int EstablishSession::SessionType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
bool SessionEstablished_SessionEstablishedResult_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const SessionEstablished_SessionEstablishedResult SessionEstablished::SUCCESS;
const SessionEstablished_SessionEstablishedResult SessionEstablished::INVALID_UNSPECIFIED;
const SessionEstablished_SessionEstablishedResult SessionEstablished::SESSIONS_LIMIT_EXCEEDED;
const SessionEstablished_SessionEstablishedResult SessionEstablished::SessionEstablishedResult_MIN;
const SessionEstablished_SessionEstablishedResult SessionEstablished::SessionEstablishedResult_MAX;
const int SessionEstablished::SessionEstablishedResult_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

// ===================================================================

void EstablishSession::InitAsDefaultInstance() {
  ::networkif::protoc::_EstablishSession_default_instance_._instance.get_mutable()->header_ = const_cast< ::networkif::protoc::GeneralHeader*>(
      ::networkif::protoc::GeneralHeader::internal_default_instance());
}
void EstablishSession::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EstablishSession::kHeaderFieldNumber;
const int EstablishSession::kSessionTypeFieldNumber;
const int EstablishSession::kPreviousSessionIdFieldNumber;
const int EstablishSession::kClientVersionFieldNumber;
const int EstablishSession::kClientVersionHashFieldNumber;
const int EstablishSession::kUpdateIntervalMinFieldNumber;
const int EstablishSession::kHeartbeatIntervalFieldNumber;
const int EstablishSession::kHeartbeatLostThresholdFieldNumber;
const int EstablishSession::kFileSizeThresholdInKBFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EstablishSession::EstablishSession()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_SessionManage_2eproto::InitDefaultsEstablishSession();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:networkif.protoc.EstablishSession)
}
EstablishSession::EstablishSession(const EstablishSession& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  previoussessionid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_previoussessionid()) {
    previoussessionid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.previoussessionid_);
  }
  clientversion_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_clientversion()) {
    clientversion_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.clientversion_);
  }
  clientversionhash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_clientversionhash()) {
    clientversionhash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.clientversionhash_);
  }
  if (from.has_header()) {
    header_ = new ::networkif::protoc::GeneralHeader(*from.header_);
  } else {
    header_ = NULL;
  }
  ::memcpy(&updateintervalmin_, &from.updateintervalmin_,
    static_cast<size_t>(reinterpret_cast<char*>(&sessiontype_) -
    reinterpret_cast<char*>(&updateintervalmin_)) + sizeof(sessiontype_));
  // @@protoc_insertion_point(copy_constructor:networkif.protoc.EstablishSession)
}

void EstablishSession::SharedCtor() {
  _cached_size_ = 0;
  previoussessionid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clientversion_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clientversionhash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&filesizethresholdinkb_) -
      reinterpret_cast<char*>(&header_)) + sizeof(filesizethresholdinkb_));
  sessiontype_ = 1;
}

EstablishSession::~EstablishSession() {
  // @@protoc_insertion_point(destructor:networkif.protoc.EstablishSession)
  SharedDtor();
}

void EstablishSession::SharedDtor() {
  previoussessionid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clientversion_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clientversionhash_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete header_;
}

void EstablishSession::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EstablishSession& EstablishSession::default_instance() {
  ::protobuf_SessionManage_2eproto::InitDefaultsEstablishSession();
  return *internal_default_instance();
}

EstablishSession* EstablishSession::New(::google::protobuf::Arena* arena) const {
  EstablishSession* n = new EstablishSession;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EstablishSession::Clear() {
// @@protoc_insertion_point(message_clear_start:networkif.protoc.EstablishSession)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!previoussessionid_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*previoussessionid_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(!clientversion_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*clientversion_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(!clientversionhash_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*clientversionhash_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(header_ != NULL);
      header_->Clear();
    }
  }
  if (cached_has_bits & 240u) {
    ::memset(&updateintervalmin_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&filesizethresholdinkb_) -
        reinterpret_cast<char*>(&updateintervalmin_)) + sizeof(filesizethresholdinkb_));
  }
  sessiontype_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EstablishSession::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:networkif.protoc.EstablishSession)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .networkif.protoc.GeneralHeader header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .networkif.protoc.EstablishSession.SessionType sessionType = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::networkif::protoc::EstablishSession_SessionType_IsValid(value)) {
            set_sessiontype(static_cast< ::networkif::protoc::EstablishSession_SessionType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string previousSessionId = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_previoussessionid()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string clientVersion = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_clientversion()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string clientVersionHash = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_clientversionhash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 updateIntervalMin = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {
          set_has_updateintervalmin();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &updateintervalmin_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 heartbeatInterval = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u /* 56 & 0xFF */)) {
          set_has_heartbeatinterval();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &heartbeatinterval_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 heartbeatLostThreshold = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u /* 64 & 0xFF */)) {
          set_has_heartbeatlostthreshold();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &heartbeatlostthreshold_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 fileSizeThresholdInKB = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(72u /* 72 & 0xFF */)) {
          set_has_filesizethresholdinkb();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &filesizethresholdinkb_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:networkif.protoc.EstablishSession)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:networkif.protoc.EstablishSession)
  return false;
#undef DO_
}

void EstablishSession::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:networkif.protoc.EstablishSession)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .networkif.protoc.GeneralHeader header = 1;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->header_, output);
  }

  // required .networkif.protoc.EstablishSession.SessionType sessionType = 2;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->sessiontype(), output);
  }

  // optional string previousSessionId = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->previoussessionid(), output);
  }

  // optional string clientVersion = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->clientversion(), output);
  }

  // optional string clientVersionHash = 5;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->clientversionhash(), output);
  }

  // optional uint32 updateIntervalMin = 6;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->updateintervalmin(), output);
  }

  // optional uint32 heartbeatInterval = 7;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->heartbeatinterval(), output);
  }

  // optional uint32 heartbeatLostThreshold = 8;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->heartbeatlostthreshold(), output);
  }

  // optional uint32 fileSizeThresholdInKB = 9;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->filesizethresholdinkb(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:networkif.protoc.EstablishSession)
}

size_t EstablishSession::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:networkif.protoc.EstablishSession)
  size_t total_size = 0;

  if (has_header()) {
    // required .networkif.protoc.GeneralHeader header = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->header_);
  }

  if (has_sessiontype()) {
    // required .networkif.protoc.EstablishSession.SessionType sessionType = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->sessiontype());
  }

  return total_size;
}
size_t EstablishSession::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:networkif.protoc.EstablishSession)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x00000108) ^ 0x00000108) == 0) {  // All required fields are present.
    // required .networkif.protoc.GeneralHeader header = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->header_);

    // required .networkif.protoc.EstablishSession.SessionType sessionType = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->sessiontype());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional string previousSessionId = 3;
    if (has_previoussessionid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->previoussessionid());
    }

    // optional string clientVersion = 4;
    if (has_clientversion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->clientversion());
    }

    // optional string clientVersionHash = 5;
    if (has_clientversionhash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->clientversionhash());
    }

  }
  if (_has_bits_[0 / 32] & 240u) {
    // optional uint32 updateIntervalMin = 6;
    if (has_updateintervalmin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->updateintervalmin());
    }

    // optional uint32 heartbeatInterval = 7;
    if (has_heartbeatinterval()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->heartbeatinterval());
    }

    // optional uint32 heartbeatLostThreshold = 8;
    if (has_heartbeatlostthreshold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->heartbeatlostthreshold());
    }

    // optional uint32 fileSizeThresholdInKB = 9;
    if (has_filesizethresholdinkb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->filesizethresholdinkb());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EstablishSession::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EstablishSession*>(&from));
}

void EstablishSession::MergeFrom(const EstablishSession& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:networkif.protoc.EstablishSession)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_previoussessionid();
      previoussessionid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.previoussessionid_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_clientversion();
      clientversion_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.clientversion_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_clientversionhash();
      clientversionhash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.clientversionhash_);
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_header()->::networkif::protoc::GeneralHeader::MergeFrom(from.header());
    }
    if (cached_has_bits & 0x00000010u) {
      updateintervalmin_ = from.updateintervalmin_;
    }
    if (cached_has_bits & 0x00000020u) {
      heartbeatinterval_ = from.heartbeatinterval_;
    }
    if (cached_has_bits & 0x00000040u) {
      heartbeatlostthreshold_ = from.heartbeatlostthreshold_;
    }
    if (cached_has_bits & 0x00000080u) {
      filesizethresholdinkb_ = from.filesizethresholdinkb_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    set_sessiontype(from.sessiontype());
  }
}

void EstablishSession::CopyFrom(const EstablishSession& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:networkif.protoc.EstablishSession)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EstablishSession::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000108) != 0x00000108) return false;
  if (has_header()) {
    if (!this->header_->IsInitialized()) return false;
  }
  return true;
}

void EstablishSession::Swap(EstablishSession* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EstablishSession::InternalSwap(EstablishSession* other) {
  using std::swap;
  previoussessionid_.Swap(&other->previoussessionid_);
  clientversion_.Swap(&other->clientversion_);
  clientversionhash_.Swap(&other->clientversionhash_);
  swap(header_, other->header_);
  swap(updateintervalmin_, other->updateintervalmin_);
  swap(heartbeatinterval_, other->heartbeatinterval_);
  swap(heartbeatlostthreshold_, other->heartbeatlostthreshold_);
  swap(filesizethresholdinkb_, other->filesizethresholdinkb_);
  swap(sessiontype_, other->sessiontype_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string EstablishSession::GetTypeName() const {
  return "networkif.protoc.EstablishSession";
}


// ===================================================================

void SessionEstablished_SuccessResponse::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SessionEstablished_SuccessResponse::kAssignedSessionIdFieldNumber;
const int SessionEstablished_SuccessResponse::kSessionObjectDistnameFieldNumber;
const int SessionEstablished_SuccessResponse::kEmbeddedClientVersionFieldNumber;
const int SessionEstablished_SuccessResponse::kEmbeddedClientVersionHashFieldNumber;
const int SessionEstablished_SuccessResponse::kUpdateIntervalMinFieldNumber;
const int SessionEstablished_SuccessResponse::kHeartbeatIntervalFieldNumber;
const int SessionEstablished_SuccessResponse::kHeartbeatLostThresholdFieldNumber;
const int SessionEstablished_SuccessResponse::kFileSizeThresholdInKBFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SessionEstablished_SuccessResponse::SessionEstablished_SuccessResponse()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_SessionManage_2eproto::InitDefaultsSessionEstablished_SuccessResponse();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:networkif.protoc.SessionEstablished.SuccessResponse)
}
SessionEstablished_SuccessResponse::SessionEstablished_SuccessResponse(const SessionEstablished_SuccessResponse& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  assignedsessionid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_assignedsessionid()) {
    assignedsessionid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.assignedsessionid_);
  }
  sessionobjectdistname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_sessionobjectdistname()) {
    sessionobjectdistname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sessionobjectdistname_);
  }
  embeddedclientversion_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_embeddedclientversion()) {
    embeddedclientversion_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.embeddedclientversion_);
  }
  embeddedclientversionhash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_embeddedclientversionhash()) {
    embeddedclientversionhash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.embeddedclientversionhash_);
  }
  ::memcpy(&updateintervalmin_, &from.updateintervalmin_,
    static_cast<size_t>(reinterpret_cast<char*>(&filesizethresholdinkb_) -
    reinterpret_cast<char*>(&updateintervalmin_)) + sizeof(filesizethresholdinkb_));
  // @@protoc_insertion_point(copy_constructor:networkif.protoc.SessionEstablished.SuccessResponse)
}

void SessionEstablished_SuccessResponse::SharedCtor() {
  _cached_size_ = 0;
  assignedsessionid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sessionobjectdistname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  embeddedclientversion_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  embeddedclientversionhash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&updateintervalmin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&filesizethresholdinkb_) -
      reinterpret_cast<char*>(&updateintervalmin_)) + sizeof(filesizethresholdinkb_));
}

SessionEstablished_SuccessResponse::~SessionEstablished_SuccessResponse() {
  // @@protoc_insertion_point(destructor:networkif.protoc.SessionEstablished.SuccessResponse)
  SharedDtor();
}

void SessionEstablished_SuccessResponse::SharedDtor() {
  assignedsessionid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sessionobjectdistname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  embeddedclientversion_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  embeddedclientversionhash_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void SessionEstablished_SuccessResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SessionEstablished_SuccessResponse& SessionEstablished_SuccessResponse::default_instance() {
  ::protobuf_SessionManage_2eproto::InitDefaultsSessionEstablished_SuccessResponse();
  return *internal_default_instance();
}

SessionEstablished_SuccessResponse* SessionEstablished_SuccessResponse::New(::google::protobuf::Arena* arena) const {
  SessionEstablished_SuccessResponse* n = new SessionEstablished_SuccessResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SessionEstablished_SuccessResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:networkif.protoc.SessionEstablished.SuccessResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!assignedsessionid_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*assignedsessionid_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(!sessionobjectdistname_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*sessionobjectdistname_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(!embeddedclientversion_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*embeddedclientversion_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(!embeddedclientversionhash_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*embeddedclientversionhash_.UnsafeRawStringPointer())->clear();
    }
  }
  if (cached_has_bits & 240u) {
    ::memset(&updateintervalmin_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&filesizethresholdinkb_) -
        reinterpret_cast<char*>(&updateintervalmin_)) + sizeof(filesizethresholdinkb_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool SessionEstablished_SuccessResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:networkif.protoc.SessionEstablished.SuccessResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string assignedSessionId = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_assignedsessionid()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required string sessionObjectDistname = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sessionobjectdistname()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string embeddedClientVersion = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_embeddedclientversion()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string embeddedClientVersionHash = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_embeddedclientversionhash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 updateIntervalMin = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          set_has_updateintervalmin();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &updateintervalmin_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 heartbeatInterval = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {
          set_has_heartbeatinterval();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &heartbeatinterval_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 heartbeatLostThreshold = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u /* 56 & 0xFF */)) {
          set_has_heartbeatlostthreshold();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &heartbeatlostthreshold_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 fileSizeThresholdInKB = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u /* 64 & 0xFF */)) {
          set_has_filesizethresholdinkb();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &filesizethresholdinkb_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:networkif.protoc.SessionEstablished.SuccessResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:networkif.protoc.SessionEstablished.SuccessResponse)
  return false;
#undef DO_
}

void SessionEstablished_SuccessResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:networkif.protoc.SessionEstablished.SuccessResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string assignedSessionId = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->assignedsessionid(), output);
  }

  // required string sessionObjectDistname = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->sessionobjectdistname(), output);
  }

  // optional string embeddedClientVersion = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->embeddedclientversion(), output);
  }

  // optional string embeddedClientVersionHash = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->embeddedclientversionhash(), output);
  }

  // optional uint32 updateIntervalMin = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->updateintervalmin(), output);
  }

  // optional uint32 heartbeatInterval = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->heartbeatinterval(), output);
  }

  // optional uint32 heartbeatLostThreshold = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->heartbeatlostthreshold(), output);
  }

  // optional uint32 fileSizeThresholdInKB = 8;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->filesizethresholdinkb(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:networkif.protoc.SessionEstablished.SuccessResponse)
}

size_t SessionEstablished_SuccessResponse::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:networkif.protoc.SessionEstablished.SuccessResponse)
  size_t total_size = 0;

  if (has_assignedsessionid()) {
    // required string assignedSessionId = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->assignedsessionid());
  }

  if (has_sessionobjectdistname()) {
    // required string sessionObjectDistname = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->sessionobjectdistname());
  }

  return total_size;
}
size_t SessionEstablished_SuccessResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:networkif.protoc.SessionEstablished.SuccessResponse)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string assignedSessionId = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->assignedsessionid());

    // required string sessionObjectDistname = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->sessionobjectdistname());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[0 / 32] & 252u) {
    // optional string embeddedClientVersion = 3;
    if (has_embeddedclientversion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->embeddedclientversion());
    }

    // optional string embeddedClientVersionHash = 4;
    if (has_embeddedclientversionhash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->embeddedclientversionhash());
    }

    // optional uint32 updateIntervalMin = 5;
    if (has_updateintervalmin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->updateintervalmin());
    }

    // optional uint32 heartbeatInterval = 6;
    if (has_heartbeatinterval()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->heartbeatinterval());
    }

    // optional uint32 heartbeatLostThreshold = 7;
    if (has_heartbeatlostthreshold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->heartbeatlostthreshold());
    }

    // optional uint32 fileSizeThresholdInKB = 8;
    if (has_filesizethresholdinkb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->filesizethresholdinkb());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SessionEstablished_SuccessResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SessionEstablished_SuccessResponse*>(&from));
}

void SessionEstablished_SuccessResponse::MergeFrom(const SessionEstablished_SuccessResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:networkif.protoc.SessionEstablished.SuccessResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_assignedsessionid();
      assignedsessionid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.assignedsessionid_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_sessionobjectdistname();
      sessionobjectdistname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sessionobjectdistname_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_embeddedclientversion();
      embeddedclientversion_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.embeddedclientversion_);
    }
    if (cached_has_bits & 0x00000008u) {
      set_has_embeddedclientversionhash();
      embeddedclientversionhash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.embeddedclientversionhash_);
    }
    if (cached_has_bits & 0x00000010u) {
      updateintervalmin_ = from.updateintervalmin_;
    }
    if (cached_has_bits & 0x00000020u) {
      heartbeatinterval_ = from.heartbeatinterval_;
    }
    if (cached_has_bits & 0x00000040u) {
      heartbeatlostthreshold_ = from.heartbeatlostthreshold_;
    }
    if (cached_has_bits & 0x00000080u) {
      filesizethresholdinkb_ = from.filesizethresholdinkb_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SessionEstablished_SuccessResponse::CopyFrom(const SessionEstablished_SuccessResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:networkif.protoc.SessionEstablished.SuccessResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SessionEstablished_SuccessResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void SessionEstablished_SuccessResponse::Swap(SessionEstablished_SuccessResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SessionEstablished_SuccessResponse::InternalSwap(SessionEstablished_SuccessResponse* other) {
  using std::swap;
  assignedsessionid_.Swap(&other->assignedsessionid_);
  sessionobjectdistname_.Swap(&other->sessionobjectdistname_);
  embeddedclientversion_.Swap(&other->embeddedclientversion_);
  embeddedclientversionhash_.Swap(&other->embeddedclientversionhash_);
  swap(updateintervalmin_, other->updateintervalmin_);
  swap(heartbeatinterval_, other->heartbeatinterval_);
  swap(heartbeatlostthreshold_, other->heartbeatlostthreshold_);
  swap(filesizethresholdinkb_, other->filesizethresholdinkb_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string SessionEstablished_SuccessResponse::GetTypeName() const {
  return "networkif.protoc.SessionEstablished.SuccessResponse";
}


// ===================================================================

void SessionEstablished::InitAsDefaultInstance() {
  ::networkif::protoc::_SessionEstablished_default_instance_._instance.get_mutable()->header_ = const_cast< ::networkif::protoc::GeneralHeader*>(
      ::networkif::protoc::GeneralHeader::internal_default_instance());
}
void SessionEstablished::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
void SessionEstablished::set_allocated_successresp(::networkif::protoc::SessionEstablished_SuccessResponse* successresp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  clear_responseDetails();
  if (successresp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      successresp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, successresp, submessage_arena);
    }
    set_has_successresp();
    responseDetails_.successresp_ = successresp;
  }
  // @@protoc_insertion_point(field_set_allocated:networkif.protoc.SessionEstablished.successResp)
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SessionEstablished::kHeaderFieldNumber;
const int SessionEstablished::kResultFieldNumber;
const int SessionEstablished::kSuccessRespFieldNumber;
const int SessionEstablished::kResultDescriptionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SessionEstablished::SessionEstablished()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_SessionManage_2eproto::InitDefaultsSessionEstablished();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:networkif.protoc.SessionEstablished)
}
SessionEstablished::SessionEstablished(const SessionEstablished& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::networkif::protoc::GeneralHeader(*from.header_);
  } else {
    header_ = NULL;
  }
  result_ = from.result_;
  clear_has_responseDetails();
  switch (from.responseDetails_case()) {
    case kSuccessResp: {
      mutable_successresp()->::networkif::protoc::SessionEstablished_SuccessResponse::MergeFrom(from.successresp());
      break;
    }
    case kResultDescription: {
      set_resultdescription(from.resultdescription());
      break;
    }
    case RESPONSEDETAILS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:networkif.protoc.SessionEstablished)
}

void SessionEstablished::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  result_ = 1;
  clear_has_responseDetails();
}

SessionEstablished::~SessionEstablished() {
  // @@protoc_insertion_point(destructor:networkif.protoc.SessionEstablished)
  SharedDtor();
}

void SessionEstablished::SharedDtor() {
  if (this != internal_default_instance()) delete header_;
  if (has_responseDetails()) {
    clear_responseDetails();
  }
}

void SessionEstablished::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SessionEstablished& SessionEstablished::default_instance() {
  ::protobuf_SessionManage_2eproto::InitDefaultsSessionEstablished();
  return *internal_default_instance();
}

SessionEstablished* SessionEstablished::New(::google::protobuf::Arena* arena) const {
  SessionEstablished* n = new SessionEstablished;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SessionEstablished::clear_responseDetails() {
// @@protoc_insertion_point(one_of_clear_start:networkif.protoc.SessionEstablished)
  switch (responseDetails_case()) {
    case kSuccessResp: {
      delete responseDetails_.successresp_;
      break;
    }
    case kResultDescription: {
      responseDetails_.resultdescription_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      break;
    }
    case RESPONSEDETAILS_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = RESPONSEDETAILS_NOT_SET;
}


void SessionEstablished::Clear() {
// @@protoc_insertion_point(message_clear_start:networkif.protoc.SessionEstablished)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(header_ != NULL);
      header_->Clear();
    }
    result_ = 1;
  }
  clear_responseDetails();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool SessionEstablished::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:networkif.protoc.SessionEstablished)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .networkif.protoc.GeneralHeader header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .networkif.protoc.SessionEstablished.SessionEstablishedResult result = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::networkif::protoc::SessionEstablished_SessionEstablishedResult_IsValid(value)) {
            set_result(static_cast< ::networkif::protoc::SessionEstablished_SessionEstablishedResult >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .networkif.protoc.SessionEstablished.SuccessResponse successResp = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_successresp()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string resultDescription = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_resultdescription()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:networkif.protoc.SessionEstablished)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:networkif.protoc.SessionEstablished)
  return false;
#undef DO_
}

void SessionEstablished::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:networkif.protoc.SessionEstablished)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .networkif.protoc.GeneralHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->header_, output);
  }

  // required .networkif.protoc.SessionEstablished.SessionEstablishedResult result = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->result(), output);
  }

  switch (responseDetails_case()) {
    case kSuccessResp:
      ::google::protobuf::internal::WireFormatLite::WriteMessage(
        3, *responseDetails_.successresp_, output);
      break;
    case kResultDescription:
      ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
        4, this->resultdescription(), output);
      break;
    default: ;
  }
  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:networkif.protoc.SessionEstablished)
}

size_t SessionEstablished::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:networkif.protoc.SessionEstablished)
  size_t total_size = 0;

  if (has_header()) {
    // required .networkif.protoc.GeneralHeader header = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->header_);
  }

  if (has_result()) {
    // required .networkif.protoc.SessionEstablished.SessionEstablishedResult result = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
  }

  return total_size;
}
size_t SessionEstablished::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:networkif.protoc.SessionEstablished)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .networkif.protoc.GeneralHeader header = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *this->header_);

    // required .networkif.protoc.SessionEstablished.SessionEstablishedResult result = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  switch (responseDetails_case()) {
    // optional .networkif.protoc.SessionEstablished.SuccessResponse successResp = 3;
    case kSuccessResp: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *responseDetails_.successresp_);
      break;
    }
    // optional string resultDescription = 4;
    case kResultDescription: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->resultdescription());
      break;
    }
    case RESPONSEDETAILS_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SessionEstablished::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SessionEstablished*>(&from));
}

void SessionEstablished::MergeFrom(const SessionEstablished& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:networkif.protoc.SessionEstablished)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_header()->::networkif::protoc::GeneralHeader::MergeFrom(from.header());
    }
    if (cached_has_bits & 0x00000002u) {
      result_ = from.result_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.responseDetails_case()) {
    case kSuccessResp: {
      mutable_successresp()->::networkif::protoc::SessionEstablished_SuccessResponse::MergeFrom(from.successresp());
      break;
    }
    case kResultDescription: {
      set_resultdescription(from.resultdescription());
      break;
    }
    case RESPONSEDETAILS_NOT_SET: {
      break;
    }
  }
}

void SessionEstablished::CopyFrom(const SessionEstablished& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:networkif.protoc.SessionEstablished)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SessionEstablished::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  if (has_header()) {
    if (!this->header_->IsInitialized()) return false;
  }
  switch (responseDetails_case()) {
    case kSuccessResp: {
      if (has_successresp()) {
        if (!this->successresp().IsInitialized()) return false;
      }
      break;
    }
    case kResultDescription: {
      break;
    }
    case RESPONSEDETAILS_NOT_SET: {
      break;
    }
  }
  return true;
}

void SessionEstablished::Swap(SessionEstablished* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SessionEstablished::InternalSwap(SessionEstablished* other) {
  using std::swap;
  swap(header_, other->header_);
  swap(result_, other->result_);
  swap(responseDetails_, other->responseDetails_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string SessionEstablished::GetTypeName() const {
  return "networkif.protoc.SessionEstablished";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace protoc
}  // namespace networkif

// @@protoc_insertion_point(global_scope)
